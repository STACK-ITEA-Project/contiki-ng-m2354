#include "dsunit.h"
#include <stdint.h>

#include "../meterif_data.c"

int adc_pushdata_process(uint8_t *data, size_t sz)
{
    return 100 + (int)sz;
}

uint8_t data1[] = {
0xF7, 0x00, 0xC7, 0xB3, 0x43, 0x5C, 0x5C, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x58, 0x2B, 0x5F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x70, 0x10, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x41, 0xB9, 0xF2, 0xA9, 0x00, 0x88, 0x16, 0xFE,
};
uint8_t data2[] = {
0xF7, 0x00, 0xC7, 0xB3, 0x43, 0x5C, 0x52, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x4D, 0x10, 0x9B, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x41, 0xBA, 0x9E, 0x8D, 0x00, 0x5D, 0x64, 0xFE,
};

void test_meterif_data(void)
{
    int i;
    uint8_t c;
    uint8_t *data;
    size_t len;
    meterif_data_context_t ctx = {0,};

    len = sizeof(data1);
    data = data1;
    meterif_data_init(&ctx);
    for (i=0; i<len; i++) {
        c = data1[i];
        meterif_data_accumulate(&ctx, data[i]);
    }
    assert_equal(meterif_data_complete(&ctx), 1);
    assert_equal(meterif_data_process(&ctx), 295);

    len = sizeof(data2);
    data = data2;
    c = data[0];
    assert_equal(meterif_data_beginning(c), 1);
    meterif_data_init(&ctx);

    for (i=0; i<3; i++) {
        meterif_data_accumulate(&ctx, data[i]);
    }

    for (i=3; i<3+ctx.len-1; i++) {
        meterif_data_accumulate(&ctx, data[i]);
    }

    meterif_data_state_t *pstate = ctx.state;
    assert_equal(pstate->count, ctx.len-1);
    c = 0;
    assert_equal(meterif_data_accumulate(&ctx, c), -1);
    assert_equal(pstate->fsm, FSM_MAX);

    meterif_data_finish(&ctx);
}

void test_meterif_data_beginning(void)
{
    assert_equal(meterif_data_beginning(0xf7), 1);
    assert_equal(meterif_data_beginning(0xfe), 0);
    assert_equal(meterif_data_beginning(0), 0);
}

void test_meterif_data_accumulate(void)
{
    meterif_data_context_t ctx = {0,};
    meterif_data_context_t *p = &ctx;
    meterif_data_state_t *pstate;
    uint16_t i;

    meterif_data_init(p);
    pstate = ctx.state;
    assert_equal(pstate->fsm, FSM_INIT);

    assert_equal(meterif_data_accumulate(NULL, data1[0]), -1);

    meterif_data_accumulate(p, data1[0]);
    assert_equal(pstate->fsm, FSM_LEN1);

    meterif_data_accumulate(p, data1[1]);
    assert_equal(pstate->fsm, FSM_LEN2);

    meterif_data_accumulate(p, data1[2]);
    assert_equal(pstate->fsm, FSM_DATA);

    assert_equal(p->len, 0xc7);

    for (i=3; i<3+p->len; ++i) {
        meterif_data_accumulate(p, data1[i]);
    }
    assert_equal(pstate->count, 0xc7);
    assert_equal(pstate->fsm, FSM_COMPLETE);
    assert_equal(meterif_data_complete(p), 1);

    meterif_data_init(p);
    pstate = ctx.state;
    assert_equal(pstate->fsm, FSM_INIT);

    meterif_data_finish(p);
}

void test_meterif_data_process(void)
{
    assert_equal(meterif_data_process(NULL), -1);
}

void main(void)
{
    _setup();
    run_test(test_meterif_data_beginning);
    run_test(test_meterif_data_accumulate);
    run_test(test_meterif_data_process);
    run_test(test_meterif_data);
}
